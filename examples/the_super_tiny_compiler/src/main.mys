class CompilerError(Error):
    message: string

@trait
class Token:
    pass

class ParenToken(Token):
    value: char

class NumberToken(Token):
    value: string

class StringToken(Token):
    value: string

class NameToken(Token):
    value: string

class StringReader:
    data: string
    pos: i64

    def __init__(self, data: string):
        self.data = data
        self.pos = 0

    def available(self) -> bool:
        return self.pos < len(self.data)

    def get(self) -> char:
        self.pos += 1

        return self.data[self.pos - 1]

    def unget(self):
        self.pos -= 1

def tokenizer(source: string) -> [Token]:
    reader = StringReader(source)
    tokens: [Token] = []

    while reader.available():
        ch = reader.get()

        if ch in ['(', ')']:
            tokens.append(ParenToken(ch))
        elif str(ch).match(re"\s") is not None:
            pass
        elif str(ch).match(re"[0-9]") is not None:
            value = ""

            while str(ch).match(re"[0-9]") is not None:
                value += ch
                ch = reader.get()

            reader.unget()
            tokens.append(NumberToken(value))
        elif ch == '"':
            value = ""
            ch = reader.get()

            while ch != '"':
                value += ch
                ch = reader.get()

            tokens.append(StringToken(value))
        elif str(ch).match(re"[a-z]"i) is not None:
            value = ""

            while str(ch).match(re"[a-z]"i) is not None:
                value += ch
                ch = reader.get()

            reader.unget()
            tokens.append(NameToken(value))
        else:
            raise CompilerError(f"I dont know what this character is: {ch}")

    return tokens

class TokenReader:
    tokens: [Token]
    pos: i64

    def __init__(self, tokens: [Token]):
        self.tokens = tokens
        self.pos = 0

    def available(self) -> bool:
        return self.pos < len(self.tokens)

    def get(self) -> Token:
        self.pos += 1

        return self.tokens[self.pos - 1]

    def unget(self):
        self.pos -= 1

@trait
class Node:
    pass

class ProgramNode(Node):
    body: [Node]

class NumberLiteralNode(Node):
    value: string

class StringLiteralNode(Node):
    value: string

class CallExpressionNode(Node):
    name: string
    params: [Node]

class CallNode(Node):
    callee: IdentifierNode
    params: [Node]

class ExpressionStatementNode(Node):
    expression: Node

class IdentifierNode(Node):
    name: string

def walk_call(reader: TokenReader) -> CallExpressionNode:
    token = reader.get()

    match token:
        case NameToken() as name_token:
            call_node = CallExpressionNode(name_token.value, [])

            while True:
                match reader.get():
                    case ParenToken() as paren_token:
                        if paren_token.value == ')':
                            return call_node

                reader.unget()
                call_node.params.append(walk(reader))
        case _:
            raise CompilerError(f"unexpected token {token}")

def walk(reader: TokenReader) -> Node:
    token = reader.get()

    match token:
        case NumberToken() as number_token:
            return NumberLiteralNode(number_token.value)
        case StringToken() as string_token:
            return StringLiteralNode(string_token.value)
        case ParenToken() as paren_token:
            if paren_token.value == '(':
                return walk_call(reader)

    raise CompilerError(f"unexpected token {token}")

def parser(tokens: [Token]) -> Node:
    ast = ProgramNode([])
    reader = TokenReader(tokens)

    while reader.available():
        ast.body.append(walk(reader))

    return ast

class Transformer:

    def traverse_array(self, body: [Node], parent: Node):
        for i, node in enumerate(body):
            body[i] = self.visit(node, parent)

    def visit(self, node: Node, parent: Node) -> Node:
        match node:
            case ProgramNode():
                return self.visit_program(node)
            case CallExpressionNode():
                return self.visit_call_expression(node, parent)
            case NumberLiteralNode():
                return self.visit_number_literal(node)
            case StringLiteralNode():
                return self.visit_string_literal(node)
            case _:
                raise CompilerError("bad node")

    def visit_program(self, node: ProgramNode) -> Node:
        self.traverse_array(node.body, None)

        return node

    def visit_call_expression(self, node: CallExpressionNode, parent: Node) -> Node:
        self.traverse_array(node.params, node)
        call_node = CallNode(IdentifierNode(node.name), node.params)

        match parent:
            case CallExpressionNode():
                return call_node
            case _:
                return ExpressionStatementNode(call_node)

    def visit_number_literal(self, node: NumberLiteralNode) -> Node:
        return node

    def visit_string_literal(self, node: StringLiteralNode) -> Node:
        return node

def transformer(ast: Node) -> Node:
    return Transformer().visit(ast, None)

def code_generator(node: Node) -> string:
    match node:
        case ProgramNode() as program_node:
            return "\n".join([code_generator(item) for item in program_node.body])
        case ExpressionStatementNode() as expression_statement_node:
            return code_generator(expression_statement_node.expression) + ";"
        case CallNode() as call_node:
            name = code_generator(call_node.callee)
            params = ", ".join([code_generator(item) for item in call_node.params])

            return f"{name}({params})"
        case IdentifierNode() as identifier_node:
            return identifier_node.name
        case NumberLiteralNode() as number_literal_node:
            return number_literal_node.value
        case StringLiteralNode() as string_literal_node:
            return f"\"{string_literal_node.value}\""
        case _:
            raise CompilerError(f"invalid node {node}")

def compiler(source: string) -> string:
    tokens = tokenizer(source)
    ast = parser(tokens)
    new_ast = transformer(ast)
    output = code_generator(new_ast)

    return output

def main(argv: [string]):
    if len(argv) > 1:
        source = argv[1]
    else:
        source = "(add 2 (subtract 4 2))"

    print("Input: ", source)
    output = compiler(source)
    print("Output:", output)

@test
def test_basic():
    assert compiler("(add 2 (subtract 4 2))") == "add(2, subtract(4, 2));"
