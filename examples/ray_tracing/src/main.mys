from math import sqrt
from math import PI
from .ray import Ray
from .vec import Vec3
from .pcg import srand
from .pcg import random_f
from string import pretty

_FLT_MAX: f32 = 340282346638528859811704183484516925440.000000

def pow(base: f32, exponent: f32) -> f32:
    return base

def tan(value: f32) -> f32:
    return value

@enum
class Materials:
    Lambertian
    Metal
    Dielectric

class Material:
    kind: Materials
    albedo: Vec3
    fuzz: f32
    ref_idx: f32

    def scatter(self, ray_in: Ray, rec: HitRec) -> (Vec3, Ray):
        match self.kind:
            case Materials.Lambertian:
                return self._lambertian_scatter(ray_in, rec)
            case Materials.Metal:
                return self._metal_scatter(ray_in, rec)
            case Materials.Dielectric:
                return self._dielectric_scatter(ray_in, rec)
            case _:
                return (None, None)

    def _lambertian_scatter(self, ray_in: Ray, rec: HitRec) -> (Vec3, Ray):
        return (self.albedo, Ray(rec.p, rec.normal + random_in_unit_sphere()))

    def _metal_scatter(self, ray_in: Ray, rec: HitRec) -> (Vec3, Ray):
        reflected = ray_in.direction.unit_vector().reflect(rec.normal)
        scattered = Ray(rec.p, reflected + random_in_unit_sphere() * self.fuzz)

        if scattered.direction.dot(rec.normal) > 0.0:
            return (self.albedo, scattered)
        else:
            return (None, None)

    def _schlick(self, cosine: f32, ref_idx: f32) -> f32:
        r0 = (1.0 - ref_idx) / (1.0 + ref_idx)
        r0 = r0 * r0

        return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0)

    def _refract(self, v: Vec3, n: Vec3, ni_over_nt: f32) -> Vec3:
        uv = v.unit_vector()
        dt = uv.dot(n)
        discriminant = 1.0 - ni_over_nt * ni_over_nt * (1.0 - dt * dt)

        if discriminant > 0.0:
            return (uv - n * dt) * ni_over_nt - n * sqrt(discriminant)
        else:
            return None

    def _dielectric_scatter(self, ray_in: Ray, rec: HitRec) -> (Vec3, Ray):
        reflected = ray_in.direction.unit_vector().reflect(rec.normal)
        reflected = ray_in.direction.reflect(rec.normal)
        attenuation = Vec3(1.0, 1.0, 1.0)
        reflect_prob: f32 = 1.0
        outward_normal = rec.normal
        ni_over_nt = 1.0 / self.ref_idx
        cosine = -ray_in.direction.dot(rec.normal) / ray_in.direction.length()

        if ray_in.direction.dot(rec.normal) > 0.0:
            outward_normal = rec.normal * -1.0
            ni_over_nt = self.ref_idx
            cosine = (self.ref_idx
                      * ray_in.direction.dot(rec.normal)
                      / ray_in.direction.length())

        refracted = self._refract(ray_in.direction, outward_normal, ni_over_nt)

        if refracted is not None:
            reflect_prob = self._schlick(cosine, self.ref_idx)
        else:
            refracted = Vec3(0.0, 0.0, 0.0)

        if random_f() < reflect_prob:
            scattered = Ray(rec.p, reflected)
        else:
            scattered = Ray(rec.p, refracted)

        return (attenuation, scattered)

class HitRec:
    t: f32
    p: Vec3
    normal: Vec3
    material: Material

class Hittable:
    center: Vec3
    radius: f32
    material: Material

class Camera:
    origin: Vec3
    lower_left_corner: Vec3
    horizontal: Vec3
    vertical: Vec3
    u: Vec3
    v: Vec3
    w: Vec3
    lens_radius: f32

    def __init__(self,
                 lookfrom: Vec3,
                 lookat: Vec3,
                 vup: Vec3,
                 vfov: f32,
                 aspect: f32,
                 aperture: f32,
                 focus_dist: f32):
        theta = vfov * f32(PI) / 180.0
        half_height = tan(theta / 2.0)
        half_width = aspect * half_height
        w = (lookfrom - lookat).unit_vector()
        u = vup.cross(w).unit_vector()
        v = w.cross(u)

        self.origin = lookfrom
        self.lower_left_corner = (lookfrom
                                  - u * half_width * focus_dist
                                  - v * half_height * focus_dist
                                  - w * focus_dist)
        self.horizontal = u * 2.0 * half_width * focus_dist
        self.vertical = v * 2.0 * half_height * focus_dist
        self.u = u
        self.v = v
        self.w = w
        self.lens_radius = aperture / 2.0

    def get_ray(self, s: f32, t: f32) -> Ray:
        rd = random_in_unit_disk() * self.lens_radius
        offset = self.u * rd.x + self.v * rd.y

        return Ray(self.origin + offset,
                   self.lower_left_corner
                   + self.horizontal * s
                   + self.vertical * t
                   - self.origin
                   - offset)

def random_in_unit_sphere() -> Vec3:
    while True:
        r1 = random_f()
        r2 = random_f()
        r3 = random_f()
        result = Vec3(r1, r2, r3) * 2.0 - Vec3(1.0, 1.0, 1.0)

        if result.squared_length() < 1.0:
            return result

def random_in_unit_disk() -> Vec3:
    while True:
        r1 = random_f()
        r2 = random_f()
        result = Vec3(r1, r2, 0.0) * 2.0 - Vec3(1.0, 1.0, 0.0)

        if result.squared_length() < 1.0:
            return result

def hit_sphere(sphere: Hittable, ray: Ray, t_min: f32, t_max: f32, rec: HitRec) -> bool:
    oc = ray.origin - sphere.center
    a = ray.direction.dot(ray.direction)
    b = oc.dot(ray.direction)
    c = oc.dot(oc) - sphere.radius * sphere.radius
    discriminant = b * b - a * c

    if discriminant > 0.0:
        temp = (-b - sqrt(discriminant)) / a

        if temp < t_max and temp > t_min:
            rec.t = temp
            rec.p = ray.point_at_parameter(rec.t)
            rec.normal = (rec.p - sphere.center) / sphere.radius
            rec.material = sphere.material

            return True

        temp = (-b + sqrt(discriminant)) / a

        if temp < t_max and temp > t_min:
            rec.t = temp
            rec.p = ray.point_at_parameter(rec.t)
            rec.normal = (rec.p - sphere.center) / sphere.radius
            rec.material = sphere.material

            return True

    return False

def hit(world: [Hittable], ray: Ray, t_min: f32, t_max: f32) -> HitRec:
    hit_anything = False
    rec: HitRec = None
    closest_so_far = t_max

    for i in range(i64(len(world))):
        temp_rec = HitRec(0.0, None, None, None)

        if hit_sphere(world[i], ray, t_min, closest_so_far, temp_rec):
            hit_anything = True
            closest_so_far = temp_rec.t
            rec = temp_rec

    return rec

def color(ray: Ray, world: [Hittable], depth: i32) -> Vec3:
    rec = hit(world, ray, 0.001, _FLT_MAX)

    if rec is not None:
        scattered = Ray(None, None)
        attenuation = Vec3(0.0, 0.0, 0.0)

        if depth < 50:
            attenuation, scattered = rec.material.scatter(ray, rec)

            if attenuation is not None:
                return attenuation * color(scattered, world, depth + 1)

        return Vec3(0.0, 0.0, 0.0)
    else:
        unit_direction = ray.direction.unit_vector()
        t = 0.5 * (unit_direction.y + 1.0)

        return Vec3(1.0, 1.0, 1.0) * (1.0 - t) + Vec3(0.5, 0.7, 1.0) * t

def random_scene() -> [Hittable]:
    world: [Hittable] = [
        Hittable(Vec3(0.0, -1000.0, 0.0),
                 1000.0,
                 Material(Materials.Lambertian, Vec3(0.5, 0.5, 0.5), 0.0, 0.0))
    ]

    for va in range(-11, 11):
        for vb in range(-11, 11):
            choose_mat = random_f()
            r1 = random_f()
            r2 = random_f()
            center = Vec3(f32(va) + 0.9 * r1, 0.2, f32(vb) + 0.9 * r2)

            if (center - Vec3(4.0, 0.2, 0.0)).length() > 0.9:
                if choose_mat < 0.8:
                    r1 = random_f()
                    r2 = random_f()
                    r3 = random_f()
                    r4 = random_f()
                    r5 = random_f()
                    r6 = random_f()
                    material = Material(Materials.Lambertian,
                                        Vec3(r1 * r2, r3 * r4, r5 * r6),
                                        0.0,
                                        0.0)
                elif choose_mat < 0.95:
                    r1 = 0.5 * (1.0 + random_f())
                    r2 = 0.5 * (1.0 + random_f())
                    r3 = 0.5 * (1.0 + random_f())
                    r4 = 0.5 * random_f()
                    material = Material(Materials.Metal,
                                        Vec3(r1, r2, r3),
                                        r4,
                                        0.0)
                else:
                    material = Material(Materials.Dielectric, None, 0.0, 1.5)

                world.append(Hittable(center, 0.2, material))

    world.append(Hittable(Vec3(0.0, 1.0, 0.0),
                          1.0,
                          Material(Materials.Dielectric, None, 0.0, 1.5)))
    world.append(Hittable(Vec3(-4.0, 1.0, 0.0),
                          1.0,
                          Material(Materials.Lambertian,
                                   Vec3(0.4, 0.2, 0.1),
                                   0.0,
                                   0.0)))
    world.append(Hittable(Vec3(4.0, 1.0, 0.0),
                          1.0,
                          Material(Materials.Metal,
                                   Vec3(0.7, 0.6, 0.5),
                                   0.0,
                                   0.0)))

    return world

def main():
    srand(0)
    nx, ny, ns = 200, 100, 1
    world = random_scene()
    # print(pretty(str(world)))
    lookfrom = Vec3(9.0, 2.0, 2.6)
    lookat = Vec3(3.0, 0.8, 1.0)
    camera = Camera(lookfrom,
                    lookat,
                    Vec3(0.0, 1.0, 0.0),
                    30.0,
                    f32(nx) / f32(ny),
                    0.0,
                    (lookfrom - lookat).length())
    # print(pretty(str(camera)))

    print("P3")
    print(f"{nx} {ny}")
    print("255")

    for j in range(ny - 1, 0, -1):
        for i in range(nx):
            col = Vec3(0.0, 0.0, 0.0)

            for s in range(ns):
                u = (f32(i) + random_f()) / f32(nx)
                v = (f32(j) + random_f()) / f32(ny)
                r = camera.get_ray(u, v)
                col = col + color(r, world, 0)

            col = col / f32(ns)
            col = Vec3(sqrt(col.x), sqrt(col.y), sqrt(col.z))
            ir = i32(255.99 * col.x)
            ig = i32(255.99 * col.y)
            ib = i32(255.99 * col.z)

            print(f"{ir} {ig} {ib}")

    print()
